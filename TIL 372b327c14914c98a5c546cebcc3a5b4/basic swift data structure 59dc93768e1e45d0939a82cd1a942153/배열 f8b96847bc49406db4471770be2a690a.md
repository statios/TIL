# 배열

### 스위프트 배열의 특징

- 단일한 타입만 저장할 수 있다
    - 프로토콜의 배열로 정의하거나 AnyObject 타입의 배열로 정의하여 다양한 타입을 저장할 수도 있다
- element로 클래스, 이넘을 포함한 어떤 타입도 가능하다
- 구조체로 정의됨

### 배열의 유형

- Array
- ContiguousArray
- ArraySlice

### Array

모든 Array는 배열에 포함된 배열 요소를 저장하기 위한 메모리 공간을 유지한다.

다만, Array는

- element type이 클래스 또는 objc 프로토콜 타입이 아닌 경우
    - 배열의 메모리 영역은 인접 블록에 저장됨
- element type이 클래스 또는 objc 프로토콜 타입인 경우
    - 배열의 메모리 영역은 인접 블록에 "NSArray의 인스턴스" 또는 "NSArray의 서브클래스의 인스턴스"로 저장됨

### Contiguous Array

[Apple Developer Documentation](https://developer.apple.com/documentation/swift/contiguousarray)

- Array와 달리 Element로 어떤 타입이 오더라도 연속적인 메모리 영역(인접 영역)에 저장한다.
- Array에서 제공되는 다양한 프로퍼티를 동일하게 소유한다
- Array와 달리 Objective-C 브릿징을 지원하지 않는다
- 따라서 Objc API에 해당 어레이를 전달할 필요가 없는경우, Element가 class 또는 objc protocol 타입인 경우에 사용하면 좋다

### ArraySlice

[Apple Developer Documentation](https://developer.apple.com/documentation/swift/arrayslice)

- Array,  ContiguousArray, ArraySlice의 속성을 그대로 지닌다.
- ContiguousArray와 마찬가지로 배열 요소를 저장할 때 인접 메모리 공간을 사용한다
- objc와의 브릿징을 지원하지 않는다
- 이미 존재하는 또 다른 배열 타입의 일부 그룹을 대표한다
- 원본인 배열의 생애주기가 끝다면 ArraySlice에 저장된 배열 요소 역시 접근 불가능 상태가 된다.
- 따라서 ArraySlice 인스턴스를 장시간 유지하지 말도록 권장된다.

### Array Capacity

[Apple Developer Documentation](https://developer.apple.com/documentation/swift/array/1538388-capacity)

- 모든 종류의 배열은 인스턴스 생성할 때 해당 배열 요소를 저장하기 위한 추가 저장 공간이 할당된다
- 배열에 메모리 공간을 재할당하지 않고 배열 관련 작업을 처리할 수 있을 정도의 잠재적인 저장 공간
- 스위프트의 배열을 기하급수적 증가 전략을 따름 ( 1 → 2 → 4 → 8 → 16...)
- 배열에 요소가 추가될 때마다 소진된 배열 용량을 자동으로 증가시킴
- 따라서 배열에 대량의 요소가 반복적으로 추가될 것임을 알 수 있는 경우 추가적인 배열 용량을 미리 할당해 두는 것이 좋다.

    ```swift
    var intArray = [Int]()
    intArray.capacity //0
    intArray.reserveCapacity(500)
    intArray.capacity //508
    // 메모리 용량을 500을 예약하더라도 스위프트가 실행능력을 고려하여 실제 요청량 이상을 확보함
    ```

### Copy on write

[Swift의 Copy-on-Write(CoW)](https://oaksong.github.io/2018/01/06/copy-on-write/)

- 배열을 복사하는 경우 저장 공간이 할당되는 동안에는 물리적으로 구분되는 별도의 복사물이 만들어지지 않는다
- 하나 이상의 배열 인스턴스가 동일한 버퍼를 공유하는 변환 작업이 완료될 때까지는 배열 요소가 실제로 복사되지 않음
- 첫번째 변환작업은 소요 시간과 저장 공간 측면에서 배열 요소의 수를 n으로 하는 O(n)

### Set

- unique
- non-nil
- 무순위
- 단일한 element 타입
- hashable, equatable 프로토콜 부합해야함 → 스위프트의 모든 기본 타입은 기본적으로 hashable
- hashable은 equatable을 상속한 프로토콜
- 세트가 배열에 비해 효율성이 우월함 → 순서가 필요없으며, 중복되지 않는 경우에는 배열보다 세트를 쓰도록하자
- 세트에서의 검색은 항상 O(1)

### Set 연산자

- union, formUnion → 두 세트의 합집합을 반환 하거나 업데이트
- intersection, formIntersection → 두 세트의 교집합을 반환하거나 업데이트
- symmetricDifference, formSymmetricDifference → 두 세트의 여집합을 반환하거나 업데이트
- subtracting, subtract → 두 세트의 차집합을 반환하거나 업데이트
- isSubset → 어떤 세트으 ㅣ요소가 특정 세트에 모두 포함돼 있는지 확인
- isStrictSubset → 어떤 세트의 요소가 특정 세트에 모두 포함돼 있지만, 동등 집합은 아님을 확인
- isSuperset → 특정 세트의 모든 요소가 또 다른 세트에 모두 포함돼 있는지 확인
- isStrictSuperset → 특정 세트의 모든 요소가 또 다른 세트에 모두 포함돼 있지만 동등 집합은 아님을 확인
- isDisjoint → 두 세트에 공통 요소가 포함돼 있는지 여부를 확인

### 튜플의 올바른 사용법

- 튜플은 별도의 구조체 타입을 쓰지 않고도 하나의 값으로 여러 타입의 데이터를 반환해야 하는 경우에 유용
- 튜플의 반환 결과가 임시 범위를 넘어서서 영구 범위까지 보장해야할 때는 다른 방법을 쓰는 것이 좋다.
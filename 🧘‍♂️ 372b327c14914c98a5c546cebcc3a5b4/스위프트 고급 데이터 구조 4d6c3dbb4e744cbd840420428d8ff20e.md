# 스위프트 고급 데이터 구조

### Iterator - IteratorProtocol

- `IteratorProtocol` 을 채택한 타입
- 컬렉션의 다음 Element를 리턴하는 `next()` 메소드 제공

```swift
public protocol IteratorProtocol {

    /// The type of element traversed by the iterator.
    associatedtype Element

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    mutating func next() -> Self.Element?
}
```

### Sequence

- Sequence 프로토콜을 채택한 타입
- for 문을 돌릴 수 있다
- `makeIterator()` → 스위프트 런타임에서 for 문을 돌릴 때 자동으로 호출됨

```swift
/// A sequence should provide its iterator in O(1). The `Sequence` protocol
/// makes no other requirements about element access, so routines that
/// traverse a sequence should be considered O(*n*) unless documented
/// otherwise.
public protocol Sequence {

    /// A type representing the sequence's elements.
    associatedtype Element where Self.Element == Self.Iterator.Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    associatedtype Iterator : IteratorProtocol

    /// Returns an iterator over the elements of this sequence.
    func makeIterator() -> Self.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    var underestimatedCount: Int { get }

    /// Call `body(p)`, where `p` is a pointer to the collection's
    /// contiguous storage.  If no such storage exists, it is
    /// first created.  If the collection does not support an internal
    /// representation in a form of contiguous storage, `body` is not
    /// called and `nil` is returned.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must also guarantee that an equivalent buffer of its `SubSequence` 
    /// can be generated by advancing the pointer by the distance to the
    /// slice's `startIndex`.
    func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?
}
```

### Collection

- Collection 프로토콜을 채택한 타입
- 시퀀스를 포함한다 (시퀀스를 상속받았다)
- 인덱스가 포함된 시퀀스를 제공한다

```swift
public protocol Collection : Sequence {

	var startIndex: Self.Index { get }
	var endIndex: Self.Index { get }

  associatedtype Iterator = IndexingIterator<Self>

  override func makeIterator() -> Self.Iterator

  associatedtype SubSequence : Collection = Slice<Self> where Self.Element == Self.SubSequence.Element, Self.SubSequence == Self.SubSequence.SubSequence

	...

}
```

### Stack

**LIFO <Last in first out> → 후입 선출**

- Array, Linked List도 스택

**필수 메소드**

- `push()` → 스택의 하단에 요소를 추가
- `pop()` → 스택 상단의 요소를 꺼내서 (삭제한 뒤) 반환
- `peek()` → 스택 상단의 요소를 꺼내서 (삭제하지 않고) 반환
- `count()` → 스택에 포함된 요소의 수를 반환
- `isEmpty()`
- `isFull()` → 스택 사이즈가 정해져 있는 경우에 사용

### Stack 구현

```swift
public struct Stack<T> {
  
  private var elements = [T]()
  
  public init() { }
  
  public mutating func pop() -> T? {
    return self.elements.popLast()
  }
  
  public mutating func push(element: T) {
    self.elements.last
  }
  
  public func peek() -> T? {
    return self.elements.last
  }
  
  public var isEmpty: Bool {
    return self.elements.isEmpty
  }

  public var count: Int {
    return self.elements.count
  }

}
```

### Stack + ExpressibleByArrayLiteral

```swift
extension Stack: ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: T...) {
    
  }
}

Stack(arrayLiteral: [1,2,3])
```

### Stack + IteractorProtocol